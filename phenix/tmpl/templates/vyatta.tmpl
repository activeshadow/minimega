{{ $ntpAddr := index . "ntp-addr" }}
{{ $node := index . "node" }}

interfaces {
{{ range $idx, $iface := $node.Network.Interfaces }}
    ethernet eth{{ $idx }} {
        address {{ $iface.Address }}/{{ $iface.Mask }}
        duplex auto
        mtu {{ $iface.MTU }}
        {{ if eq $iface.Proto "OSPF" }}
        ip {
            ospf {
                dead-interval {{ $node.Network.OSPF.DeadInterval }}
                hello-interval {{ $node.Network.OSPF.HelloInterval }}
                retransmit-interval {{ $node.Network.OSPF.RetransInterval }}
                transmit-delay 1
            }
        }
        {{ end }}
        {{ if ne $node.Network.Rulesets "" }}
        firewall {
            {{ range $rule := $node.Network.Rulesets }}
                {{/* TODO: BTR to understand acl.filter_type */}}
                {{/* if eq .FIXME "send" */}}
                {{/* $filter = "out" */}}
                {{/* else if eq .FIXME "receive" */}}
                {{/* $filter = "in" */}}
                {{/* end */}}
                {{/* remove `none ` from the below and uncomment $filter */}}
                {{/* $filter */}} none {
                    name {{ $rule.Name }}
                }
            {{ end }}
        }
        {{ end }}
        {{/* TODO: BTR to determine router.loopback_ip and mask */}}
        {{ if ne .FIXME "None" }}
        loopback lo {
            address {{ .FIXME }}/{{ .FIXME }}
        }
        {{ end }}
    }
{{ end }}
}

{{ $nat := 10 }}
nat {
{{ range $iface }}
   {{/* TODO: need to determine length of nat_config (see line 50 in mako) */}}
   {{ if gt .FIXME 0 }}
   source {
       rule {{ $n }} {
           {{/* TODO: need to determine nat_config */}}
           {{ $ifaceNum := .FIXME }}
           outbound-interface eth{{ .FIXME }}
           {{ if ne .FIXME "" }}
           source {
               address {{ .FIXME }}/{{ .FIXME }}
           }
           {{ end }}
           translation {
               {{ if eq .FIXME "overload" }}
               address masquerade
               {{ else if eq .FIXME "static" }}
               address {{ .FIXME }}
               {{ end }}
           }
       }
       {{ $n += 1 }}
   }
    {{ end }}
{{ end }}
}

{{ $hasFirewall := false }}
{{ range $rules := $node.Network.Rulesets }}
    {{ if ne $rules.Default "" }}
    {{ $hasFirewall = true }}
firewall {
    {{ end }}
    {{ if ne $rules.Default "" }}
    name {{ $rules.Name }} {
        default-action {{ $rules.Default }}
        description "{{ $rules.Description }}"
        {{ range $idx, $rule := $rules.Rules }}
        rule {{ $rule.ID }} {
            action {{ $rule.Action }}
            {{ if ne $rules.Default "" }}
            description "{{ $rule.Description }}"
            {{ end }}
            {{ if ne $rule.Source.Address "" }}
            protocol {{ $rule.Protocol }}
            source {
                address {{ $rule.Source.Address }}
                {{ if ne $rule.Source.Port "" }}
                port {{ $rule.Source.Port }}
                {{ end }}
            }
            {{ end }}
            {{ if ne $rule.Destination.Address "" }}
            destination {
                address {{ $rule.Destination.Address }}
                {{ if ne $rule.Destination.Port "" }}
                port {{ $rule.Destination.Port }}
                {{ end }}
            }
            {{ end }}
        }
        {{ end }}
    }
    {{ end }}
    {{ if $hasFirewall && if ne $rules.Default "" }}
}
    {{ end }}
{{ end }}

{{/* Do we need the following? */}}
protocols {
    static {
    {{ range $route := $node.Network.Routes }}
        route {{ $route.Destination }} {
            next-hop {{ $route.Next }} {
                distance {{ $route.Cost }}
            }
        }
    {{ end }}
    }

    ospf {
    {{ range $areas := $node.Network.OSPF.Areas }}
        area {{ $areas.AreaID }} {
        {{ range $areas.AreaNetworks }}
            network {{ $areas.AreaNetwork.Network }}
        {{ end }}
        }
        parameters {
            router-id {{ $node.Network.OSPF.RouterID }}
        }
        redistribute {
        {{/* TODO: need to determine ospf_bgp_redis */}}
        {{ if .FIXME }}
            bgp {
                {{/* See lines 146-148 on vyatta.mako */}}
            }
        {{ end }}
        {{/* TODO: need to determine ospf_connected_redis */}}
        {{ if .FIXME }}
            connected {

            }
        {{ end }}
        {{/* TODO: need to determine ospf_static_redis */}}
        {{ if .FIXME }}
            static {

            }
        {{ end }}
        }
    }

    {{/* TODO: need to determine length of router.bgp */}}
    {{ if gt .FIXME 0 }}
    {{/* TODO: need to determine as_number */}}
    bgp {{ .FIXME }} {
    {{/* TODO: need to determine neighbors */}}
    {{ range .FIXME }}
        neighbor {{ .FIXME }} {
            nexthop-self
            remote-as {{ .FIXME }}
        }
    {{ end }}

        redistribute {
        {{/* TODO: need to determine ospf_redis */}}
        {{ if .FIXME }}
            ospf {

            }
        {{ end }}
        {{/* TODO: need to determine static_redis */}}
        {{ if .FIXME }}
            static {

            }
        {{ end }}
        {{/* TODO: need to determine connected_redis */}}
        {{ if .FIXME }}
            connected {

            }
        {{ end }}
        {{/* TODO: need to determine rip_redis */}}
        {{ if .FIXME }}
            rip {

            }
        {{ end }}
        }
    }
    {{ end }}
}
{{/* end protocol block */}}

{{/* TODO: need to add Ipsec VPN content */}}

system {
    host-name {{ $node.RouterName }}
{{ if ne $ntpAddr "" }}
    ntp {
        server {{ $ntpAddr }} {
            perfer
        }
    }
{{ end }}
}
/* Warning: Do not remove the following line. */
/* === vyatta-config-version: "dhcp-relay@1:vrrp@1:zone-policy@1:content-inspection@3:webproxy@1:quagga@2:webgui@1:wanloadbalance@3:ipsec@3:firewall@4:conntrack-sync@1:cluster@1:system@4:qos@1:nat@3:dhcp-server@4:config-management@1" === */
/* Release version: VC6.3-2011.07.21 */